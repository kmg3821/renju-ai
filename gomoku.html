<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">
  <title>Gomoku GUI (15x15)</title>
  <style>
    :root{
      --board-color: #DEB887; /* light brown */
      --line-color: #6b4f33; /* dark brown */
      --star-radius: 4;
    }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:#f3f3f3}
    .container{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;gap:16px}
    .board-wrap{background:var(--board-color);padding:18px;border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,0.12)}
    canvas#board{display:block;touch-action:none;background:transparent;border-radius:6px}
    .controls{display:flex;gap:8px;align-items:center;justify-content:center}
    button{padding:8px 12px;border-radius:8px;border:1px solid rgba(0,0,0,0.12);background:white;cursor:pointer}
    .info{font-size:14px;color:#333}
    @media (max-width:600px){
      .board-wrap{padding:10px}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="info" id="turnInfo"> </div>
    <div class="controls">
      <label>
        <input type="radio" name="firstPlayer" value="1" checked> You First
      </label>
      <label>
        <input type="radio" name="firstPlayer" value="2"> AI First
      </label>
      <button onclick="startGame()">Start Game</button>
    </div>
    <div class="board-wrap">
      <canvas id="board" width="720" height="720" aria-label="Gomoku board"></canvas>
    </div>
  </div>

  <script>
    // Gomoku GUI: 15x15 intersections
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    const SIZE = 15; // intersections per side
    // margins around drawing area inside canvas
    const margin = 36; // pixels

    // board drawing area
    const W = canvas.width;
    const H = canvas.height;

    const gridW = W - margin*2;
    const gridH = H - margin*2;
    const cellW = gridW / (SIZE - 1);
    const cellH = gridH / (SIZE - 1);

    // store board state: 0 empty, 1 black, 2 white
    const board = Array.from({length: SIZE}, _ => Array(SIZE).fill(0));
    let turn = 0;
    let pendRow = -1
    let pendCol = -1;
    let isWaiting = false;
    let gameStarted = false;

    function drawBoard(){
      // clear with board color
      ctx.clearRect(0,0,W,H);
      // background rectangle (light brown)
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-color').trim() || '#DEB887';
      roundRect(ctx, margin-12, margin-12, gridW+24, gridH+24, 10, true, false);

      // draw grid lines
      ctx.strokeStyle = '#6b4f33';
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      for(let i=0;i<SIZE;i++){
        // horizontal
        const y = margin + i * cellH;
        ctx.beginPath();
        ctx.moveTo(margin, Math.round(y)+0.5);
        ctx.lineTo(margin + gridW, Math.round(y)+0.5);
        ctx.stroke();
        // vertical
        const x = margin + i * cellW;
        ctx.beginPath();
        ctx.moveTo(Math.round(x)+0.5, margin);
        ctx.lineTo(Math.round(x)+0.5, margin + gridH);
        ctx.stroke();
      }
    }

    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      if (typeof r === 'undefined') r = 5;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    function drawStone(col, row, color){
      const cx = margin + col * cellW;
      const cy = margin + row * cellH;
      const radius = Math.min(cellW, cellH) * 0.42; // stone size relative to cell

      ctx.save();
      // shadow
      ctx.beginPath();
      ctx.arc(cx + 1, cy + 2, radius, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fill();

      // stone
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI*2);
      if(color === 1){
        // glossy black stone
        const grad = ctx.createRadialGradient(cx - radius*0.4, cy - radius*0.6, radius*0.1, cx, cy, radius);
        grad.addColorStop(0, '#555');
        grad.addColorStop(0.3, '#000');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.fill();
      } else {
        // white stone with subtle border and shading
        const grad = ctx.createRadialGradient(cx - radius*0.4, cy - radius*0.6, radius*0.1, cx, cy, radius);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.7, '#eee');
        grad.addColorStop(1, '#ddd');
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = 'rgba(0,0,0,0.18)';
        ctx.stroke();
      }
      ctx.restore();
    }

    function sendBoardState(action){
      isWaiting = true;
      let data = '';
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          data += board[r][c].toString();
        }
      }
      data += "," + turn.toString().padStart(3,'0') + "," + action.toString().padStart(3,'0')
      fetch('/play', {
        method: 'POST',
        headers: {'Content-Type': 'text/plain'},
        body: data
      })
      .then(response => response.text())
      .then(data => {
        const tmp = data.split(',');
        const result = Number(tmp[0]);
        const action = Number(tmp[1]);
        const value = Number(tmp[2]);
        if(result !== 0) {
          gameStarted = false;
          if(action === -1) {
            // terminated by you
            if(result === 1) document.getElementById('turnInfo').textContent = "You win";
            else if(result === 2) document.getElementById('turnInfo').textContent = "You lose";
            else document.getElementById('turnInfo').textContent = "Draw";
            return;
          }
          else {
            // terminated by AI
            if(result === 1) document.getElementById('turnInfo').textContent = "AI win";
            else if(result === 2) document.getElementById('turnInfo').textContent = "AI lose";
            else document.getElementById('turnInfo').textContent = "Draw";
          }
        }
        const row = Math.floor(action/SIZE);
        const col = action%SIZE;
        board[row][col] = turn%2 + 1;
        drawStone(col, row, turn%2 + 1);
        turn += 1;
        isWaiting = false;
      })
      .catch(err => console.error('Failed to send board state:', err));
    }

    // convert client coordinates to board indices
    function getNearestIntersection(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);

      let tmp;
      let col = (x - margin) / cellW;
      tmp = Math.floor(col*10) % 10;
      if(tmp >= 3 && tmp <= 7) return {row: -2};
      let row = (y - margin) / cellH;
      tmp = Math.floor(row*10) % 10;
      if(tmp >= 3 && tmp <= 7) return {row: -2};

      col = Math.round(col);
      row = Math.round(row);
      
      // clamp
      col = Math.max(0, Math.min(SIZE-1, col));
      row = Math.max(0, Math.min(SIZE-1, row));
      return {col, row};
    }

    // click handler
    function placeStoneAt(clientX, clientY){
      if(gameStarted === false) return false;
      if(pendRow === -1) return false;
      const {col, row} = getNearestIntersection(clientX, clientY);
      if(row == -2) return false;
      if(row !== pendRow || col !== pendCol) return false;
      board[row][col] = turn%2 + 1;
      drawStone(col, row, turn%2 + 1);
      turn += 1;
      sendBoardState(SIZE*row + col);
      return true;
    }

    function pendStoneAt(clientX, clientY){
      if(gameStarted === false) return false;
      const {col, row} = getNearestIntersection(clientX, clientY);
      if(row == -2) return false;
      if(board[row][col] !== 0) return false;
      pendRow = row;
      pendCol = col;
      return true;
    }

    // handle mouse and touch
    canvas.addEventListener('pointerdown', (e)=>{
      if(isWaiting === true) return;
      if(e.pointerType === 'mouse' && e.button !== 0) return;
      pendStoneAt(e.clientX, e.clientY);
    });

    // handle mouse and touch
    canvas.addEventListener('pointerup', (e)=>{
      if(e.pointerType === 'mouse' && e.button !== 0) return;
      placeStoneAt(e.clientX, e.clientY);
      pendRow = -1;
    });

    function startGame() {
      const selected = document.querySelector('input[name="firstPlayer"]:checked').value;
      player = parseInt(selected);
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) board[r][c]=0;
      turn = 0;
      pendRow = -1
      pendCol = -1;
      isWaiting = false;
      gameStarted = true;
      drawBoard();
      document.getElementById('turnInfo').textContent = "Game started";
      if(player === 2) {
        board[7][7] = 1;
        drawStone(7, 7, 1);
        turn = 1;
      }
    }

    // prevent context menu on right click
    canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

    // initial draw
    drawBoard();

    // make canvas resize gracefully when window resizes while keeping aspect ratio
    (function makeResponsive(){
      function fit(){
        const maxWidth = Math.min(window.innerWidth - 40, 720);
        const size = Math.max(320, maxWidth);
        canvas.style.width = size + 'px';
        canvas.style.height = size + 'px';
      }
      window.addEventListener('resize', fit);
      fit();
    })();

  </script>
</body>
</html>
